---
# generated by https://github.com/hashicorp/terraform-plugin-docs
page_title: "{{.Name}} {{.Type}} - {{.RenderedProviderName}}"
subcategory: ""
description: |-
{{ .Description | plainmarkdown | trimspace | prefixlines "  " }}
---

# {{.Name}} ({{.Type}})

{{ .Description | trimspace }}

_Reference: <https://developer.hashicorp.com/terraform/plugin/framework/resources>_

{{ if .HasExamples -}}
## Example Usage

{{- range .ExampleFiles }}

{{ tffile . }}
{{- end }}
{{- end }}

{{ .SchemaMarkdown | trimspace }}
{{- if or .HasImport .HasImportIDConfig .HasImportIdentityConfig }}

## Import

Import is supported using the following syntax:
{{- end }}
{{- if .HasImportIdentityConfig }}

In Terraform v1.12.0 and later, the [`import` block](https://developer.hashicorp.com/terraform/language/import) can be used with the `identity` attribute, for example:

{{tffile .ImportIdentityConfigFile }}

{{ .IdentitySchemaMarkdown | trimspace }}
{{- end }}
{{- if .HasImportIDConfig }}

In Terraform v1.5.0 and later, the [`import` block](https://developer.hashicorp.com/terraform/language/import) can be used with the `id` attribute, for example:

{{tffile .ImportIDConfigFile }}
{{- end }}
{{- if .HasImport }}

The [`terraform import` command](https://developer.hashicorp.com/terraform/cli/commands/import) can be used, for example:

{{codefile "shell" .ImportFile }}
{{- end }}

## TypeScript Implementation

Resources can be either **stateful** or **stateless**:

- **Stateful Resources**: Maintain additional computed state beyond the ID and props (e.g., timestamps, checksums, server-generated values)
- **Stateless Resources**: Only need an ID and props, without additional state tracking

### Stateless Resource Example

When you don't need to track additional state, omit the state type parameter:

```ts
import { ResourceProvider } from "@brad-jones/terraform-provider-denobridge";

interface Props {
  path: string;
  content: string;
}

new ResourceProvider<Props>({
  async create({ path, content }) {
    await Deno.writeTextFile(path, content);

    // For stateless resources, only return the ID
    return { id: path };
  },
  async read(id, props) {
    try {
      const content = await Deno.readTextFile(id);
      // Return only props, no state
      return { props: { path: id, content } };
    } catch (e) {
      if (e instanceof Deno.errors.NotFound) {
        return { exists: false };
      }
      throw e;
    }
  },
  async update(id, nextProps, currentProps) {
    if (nextProps.path !== currentProps.path) {
      throw new Error("Cannot change file path - requires resource replacement");
    }
    await Deno.writeTextFile(id, nextProps.content);
    // No state to return
  },
  async delete(id, props) {
    await Deno.remove(id);
  },
  async modifyPlan(_id, planType, nextProps, currentProps) {
    if (planType !== "update") return;
    return { requiresReplacement: currentProps?.path !== nextProps.path };
  },
});
```

### Stateful Resource Example

When you need to track additional computed state, provide both props and state types:

```ts
import { ResourceProvider } from "@brad-jones/terraform-provider-denobridge";

interface Props {
  path: string;
  content: string;
}

interface State {
  mtime: number;
  sensitive: {
    secret: string;
  };
}

new ResourceProvider<Props, State>({
  async create({ path, content }) {
    await Deno.writeTextFile(path, content);

    return {
      // At minimum, the create endpoint must return an id that uniquely identifies this resource.
      id: path,

      // Optional additional state that is only known after the resource is created can be returned in the state object.
      state: {
        mtime: (await Deno.stat(path)).mtime!.getTime(),
        // Sensitive values can be nested under a "sensitive" key to mark them as sensitive in Terraform
        sensitive: {
          secret: "api-key-or-password",
        },
      },
    };
  },
  async read(id, props) {
    // The read methods job is to get the current state of an existing resource.
    // And return an updated set of props & optional additional state that may
    // have changed (by outside actors), since the resource was initially created
    // (or last updated).
    try {
      const content = await Deno.readTextFile(id);
      return {
        props: { path: id, content },
        state: {
          mtime: (await Deno.stat(id)).mtime!.getTime(),
          sensitive: {
            secret: "api-key-or-password",
          },
        },
      };
    } catch (e) {
      if (e instanceof Deno.errors.NotFound) {
        // In the event we can no longer locate the resource we should signal
        // to tf to remove the resource from state. This will cause tf to re-create
        // the resource on the next plan.
        return { exists: false };
      }
      throw e;
    }
  },
  async update(id, nextProps, currentProps, currentState) {
    // In this case an in place update is not supported for a file when the path
    // changes because that would mean the ID would change too & tf can't deal with that easily.
    // So we return an error here but if an update wouldn't result in a new ID, there is no need to return such an error.
    // Or implement the /modify-plan endpoint, which should have caught this & told tf to do a replacement instead (ie: create then delete).
    if (nextProps.path !== currentProps.path) {
      throw new Error("Cannot change file path - requires resource replacement");
    }

    // Perform the update
    await Deno.writeTextFile(id, nextProps.content);

    // Return the updated state
    return {
      mtime: (await Deno.stat(id)).mtime!.getTime(),
      sensitive: {
        secret: "api-key-or-password",
      },
    };
  },
  async delete(id, _props, _state) {
    await Deno.remove(id);
  },
  async modifyPlan(_id, planType, nextProps, currentProps, currentState) {
    // If you decide you don't want to make any changes to the plan, just return a 204 No Content response.
    if (planType !== "update") {
      return;
    }

    // The most common use case for this endpoint is to tell tf if the resource
    // requires replacement (ie: create then delete) instead of an inline update.
    return { requiresReplacement: currentProps?.path !== nextProps.path };

    // Other use cases include returning a set of modifiedProps.
    // For example to provide default values for any unset props.
    // eg: return { modifiedProps: { content: nextProps?.content ?? "Hello World" } }

    // Or returning diagnostics, eg: for Destroy plans. As well as any other validation.
    // see: https://developer.hashicorp.com/terraform/plugin/framework/resources/plan-modification#resource-destroy-plan-diagnostics
    // eg: return {
    //   diagnostics: [{
    //     severity: "warning",
    //     summary: "Resource Destruction Considerations",
    //     detail: `Applying this resource destruction will only remove the resource
    //             from the Terraform state and will not call the deletion API due to API limitations.
    //             Manually use the web interface to fully destroy this resource.`
    //   }]
    // }
  },
});
```

### Sensitive State

Resources can return sensitive values (like API keys, passwords, or tokens) that should be marked as sensitive in Terraform. Sensitive values will not be displayed in logs or plan output.

To mark state as sensitive, nest it under a `sensitive` key within your state object:

```ts
interface State {
  mtime: number;
  sensitive: {
    apiKey: string;
    password: string;
  };
}

new ResourceProvider<Props, State>({
  async create(props) {
    // ... create resource
    return {
      id: "resource-id",
      state: {
        mtime: Date.now(),
        sensitive: {
          apiKey: "secret-api-key",
          password: "secret-password",
        },
      },
    };
  },
  // ... other methods also return sensitive state
});
```

The `sensitive` field is automatically separated from the rest of the state and stored in the `sensitive_state` attribute of the resource, which is marked as sensitive in the Terraform schema.

**Important**: When accessing `currentState` in the `update`, `delete`, or `modifyPlan` methods, the sensitive values will be available under `currentState.sensitive`.

### Zod Validation

The `ZodResourceProvider` ensures all input & outputs to & from your TypeScript provider are validated at runtime.

#### Stateless with Zod

For stateless resources, provide only the props schema:

```ts
import { z } from "jsr:@zod/zod";
import { ZodResourceProvider } from "@brad-jones/terraform-provider-denobridge";

const Props = z.object({
  path: z.string(),
  content: z.string(),
});

new ZodResourceProvider(Props, {
  async create({ path, content }) {
    await Deno.writeTextFile(path, content);
    return { id: path };
  },
  async read(id, props) {
    const content = await Deno.readTextFile(id);
    return { props: { path: id, content } };
  },
  async update(id, nextProps, currentProps) {
    await Deno.writeTextFile(id, nextProps.content);
  },
  async delete(id, props) {
    await Deno.remove(id);
  },
  // ... other methods
});
```

#### Stateful with Zod

For stateful resources, provide both props and state schemas:

```ts
import { z } from "jsr:@zod/zod";
import { ZodResourceProvider } from "@brad-jones/terraform-provider-denobridge";

const Props = z.object({
  path: z.string(),
  content: z.string(),
});

const State = z.object({
  mtime: z.number(),
  sensitive: z.object({
    secret: z.string(),
  }),
});

new ZodResourceProvider(Props, State, {
  // as above but validated...
});
```
