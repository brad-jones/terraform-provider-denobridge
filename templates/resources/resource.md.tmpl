---
# generated by https://github.com/hashicorp/terraform-plugin-docs
page_title: "{{.Name}} {{.Type}} - {{.RenderedProviderName}}"
subcategory: ""
description: |-
{{ .Description | plainmarkdown | trimspace | prefixlines "  " }}
---

# {{.Name}} ({{.Type}})

{{ .Description | trimspace }}

_Reference: <https://developer.hashicorp.com/terraform/plugin/framework/resources>_

{{ if .HasExamples -}}
## Example Usage

{{- range .ExampleFiles }}

{{ tffile . }}
{{- end }}
{{- end }}

{{ .SchemaMarkdown | trimspace }}

## Write-Only Properties

Write-only properties (available in Terraform 1.11+) allow you to pass sensitive or ephemeral data to your resource without storing it in Terraform state. This is particularly useful when working with ephemeral resources like temporary credentials or tokens.

### Usage Example

```terraform
ephemeral "denobridge_ephemeral_resource" "api_token" {
  path = "./get_token.ts"
  props = {
    service = "example-api"
  }
}

resource "denobridge_resource" "api_call" {
  path  = "./resource.ts"
  props = {
    endpoint = "https://api.example.com"
    action = "create"
  }

  # Write-only props are not stored in state
  write_only_props = {
    apiToken = ephemeral.denobridge_ephemeral_resource.api_token.result.token
  }
}
```

### How It Works

1. **No State Storage**: Write-only properties are never stored in Terraform state
2. **Change Detection**: Changes to write-only properties trigger resource updates via the `write_only_props_version` field
3. **Passed to Script**: Write-only properties are available to your Deno script under `props.writeOnly`

### In Your TypeScript Implementation

Access write-only properties through the `writeOnly` nested field in your props interface:

```ts
interface Props {
  endpoint: string;
  action: string;

  // Write-only properties nested under "writeOnly" key
  writeOnly?: {
    apiToken: string;
  };
}

new ResourceProvider<Props>({
  async create(props) {
    // Access write-only data
    const token = props.writeOnly?.apiToken;

    // Use it to create the resource
    await makeApiCall(props.endpoint, token);

    return { id: "resource-id" };
  },
  // ... other methods can also access props.writeOnly
});
```

**Important Notes:**
- Write-only properties are separate from sensitive state values
- Sensitive state values are stored (but marked as sensitive), while write-only properties are never stored
- Changes to write-only properties will cause an update operation, not just a plan refresh

{{- if or .HasImport .HasImportIDConfig .HasImportIdentityConfig }}

## Import

Import is supported using the following syntax:
{{- end }}
{{- if .HasImportIdentityConfig }}

In Terraform v1.12.0 and later, the [`import` block](https://developer.hashicorp.com/terraform/language/import) can be used with the `identity` attribute, for example:

{{tffile .ImportIdentityConfigFile }}

{{ .IdentitySchemaMarkdown | trimspace }}
{{- end }}
{{- if .HasImportIDConfig }}

In Terraform v1.5.0 and later, the [`import` block](https://developer.hashicorp.com/terraform/language/import) can be used with the `id` attribute, for example:

{{tffile .ImportIDConfigFile }}
{{- end }}
{{- if .HasImport }}

The [`terraform import` command](https://developer.hashicorp.com/terraform/cli/commands/import) can be used, for example:

{{codefile "shell" .ImportFile }}
{{- end }}

## TypeScript Implementation

Resources can be either **stateful** or **stateless**:

- **Stateful Resources**: Maintain additional computed state beyond the ID and props (e.g., timestamps, checksums, server-generated values)
- **Stateless Resources**: Only need an ID and props, without additional state tracking

### Stateless Resource Example

When you don't need to track additional state, omit the state type parameter:

```ts
import { ResourceProvider } from "@brad-jones/terraform-provider-denobridge";

interface Props {
  path: string;
  content: string;

  // Optional write-only properties (not stored in state)
  writeOnly?: {
    secretKey: string;
  };
}

new ResourceProvider<Props>({
  async create({ path, content }) {
    await Deno.writeTextFile(path, content);

    // For stateless resources, only return the ID
    return { id: path };
  },
  async read(id, props) {
    try {
      const content = await Deno.readTextFile(id);
      // Return only props, no state
      return { props: { path: id, content } };
    } catch (e) {
      if (e instanceof Deno.errors.NotFound) {
        return { exists: false };
      }
      throw e;
    }
  },
  async update(id, nextProps, currentProps) {
    if (nextProps.path !== currentProps.path) {
      throw new Error("Cannot change file path - requires resource replacement");
    }
    await Deno.writeTextFile(id, nextProps.content);
    // No state to return
  },
  async delete(id, props) {
    await Deno.remove(id);
  },
  async modifyPlan(_id, planType, nextProps, currentProps) {
    if (planType !== "update") return;
    return { requiresReplacement: currentProps?.path !== nextProps.path };
  },
});
```

### Stateful Resource Example

When you need to track additional computed state, provide both props and state types:

```ts
import { ResourceProvider } from "@brad-jones/terraform-provider-denobridge";

interface Props {
  path: string;
  content: string;

  // Optional write-only properties (not stored in state)
  writeOnly?: {
    secretKey: string;
  };
}

interface State {
  mtime: number;
  sensitive: {
    secret: string;
  };
}

new ResourceProvider<Props, State>({
  async create({ path, content }) {
    await Deno.writeTextFile(path, content);

    return {
      // At minimum, the create endpoint must return an id that uniquely identifies this resource.
      id: path,

      // Optional additional state that is only known after the resource is created can be returned in the state object.
      state: {
        mtime: (await Deno.stat(path)).mtime!.getTime(),
        // Sensitive values can be nested under a "sensitive" key to mark them as sensitive in Terraform
        sensitive: {
          secret: "api-key-or-password",
        },
      },
    };
  },
  async read(id, props) {
    // The read methods job is to get the current state of an existing resource.
    // And return an updated set of props & optional additional state that may
    // have changed (by outside actors), since the resource was initially created
    // (or last updated).
    try {
      const content = await Deno.readTextFile(id);
      return {
        props: { path: id, content },
        state: {
          mtime: (await Deno.stat(id)).mtime!.getTime(),
          sensitive: {
            secret: "api-key-or-password",
          },
        },
      };
    } catch (e) {
      if (e instanceof Deno.errors.NotFound) {
        // In the event we can no longer locate the resource we should signal
        // to tf to remove the resource from state. This will cause tf to re-create
        // the resource on the next plan.
        return { exists: false };
      }
      throw e;
    }
  },
  async update(id, nextProps, currentProps, currentState) {
    // In this case an in place update is not supported for a file when the path
    // changes because that would mean the ID would change too & tf can't deal with that easily.
    // So we return an error here but if an update wouldn't result in a new ID, there is no need to return such an error.
    // Or implement the /modify-plan endpoint, which should have caught this & told tf to do a replacement instead (ie: create then delete).
    if (nextProps.path !== currentProps.path) {
      throw new Error("Cannot change file path - requires resource replacement");
    }

    // Perform the update
    await Deno.writeTextFile(id, nextProps.content);

    // Return the updated state
    return {
      mtime: (await Deno.stat(id)).mtime!.getTime(),
      sensitive: {
        secret: "api-key-or-password",
      },
    };
  },
  async delete(id, _props, _state) {
    await Deno.remove(id);
  },
  async modifyPlan(_id, planType, nextProps, currentProps, currentState) {
    // If you decide you don't want to make any changes to the plan, just return a 204 No Content response.
    if (planType !== "update") {
      return;
    }

    // The most common use case for this endpoint is to tell tf if the resource
    // requires replacement (ie: create then delete) instead of an inline update.
    return { requiresReplacement: currentProps?.path !== nextProps.path };

    // Other use cases include returning a set of modifiedProps.
    // For example to provide default values for any unset props.
    // eg: return { modifiedProps: { content: nextProps?.content ?? "Hello World" } }

    // Or returning diagnostics, eg: for Destroy plans. As well as any other validation.
    // see: https://developer.hashicorp.com/terraform/plugin/framework/resources/plan-modification#resource-destroy-plan-diagnostics
    // eg: return {
    //   diagnostics: [{
    //     severity: "warning",
    //     summary: "Resource Destruction Considerations",
    //     detail: `Applying this resource destruction will only remove the resource
    //             from the Terraform state and will not call the deletion API due to API limitations.
    //             Manually use the web interface to fully destroy this resource.`
    //   }]
    // }
  },
});
```

### Sensitive State

Resources can return sensitive values (like API keys, passwords, or tokens) that should be marked as sensitive in Terraform. Sensitive values will not be displayed in logs or plan output.

To mark state as sensitive, nest it under a `sensitive` key within your state object:

```ts
interface State {
  mtime: number;
  sensitive: {
    apiKey: string;
    password: string;
  };
}

new ResourceProvider<Props, State>({
  async create(props) {
    // ... create resource
    return {
      id: "resource-id",
      state: {
        mtime: Date.now(),
        sensitive: {
          apiKey: "secret-api-key",
          password: "secret-password",
        },
      },
    };
  },
  // ... other methods also return sensitive state
});
```

The `sensitive` field is automatically separated from the rest of the state and stored in the `sensitive_state` attribute of the resource, which is marked as sensitive in the Terraform schema.

**Important**: When accessing `currentState` in the `update`, `delete`, or `modifyPlan` methods, the sensitive values will be available under `currentState.sensitive`.

### Zod Validation

The `ZodResourceProvider` ensures all input & outputs to & from your TypeScript provider are validated at runtime.

#### Stateless with Zod

For stateless resources, provide only the props schema:

```ts
import { z } from "jsr:@zod/zod";
import { ZodResourceProvider } from "@brad-jones/terraform-provider-denobridge";

const Props = z.object({
  path: z.string(),
  content: z.string(),
  // Optional write-only properties (not stored in state)
  writeOnly: z.object({
    secretKey: z.string(),
  }).optional(),
});

new ZodResourceProvider(Props, {
  async create({ path, content }) {
    await Deno.writeTextFile(path, content);
    return { id: path };
  },
  async read(id, props) {
    const content = await Deno.readTextFile(id);
    return { props: { path: id, content } };
  },
  async update(id, nextProps, currentProps) {
    await Deno.writeTextFile(id, nextProps.content);
  },
  async delete(id, props) {
    await Deno.remove(id);
  },
  // ... other methods
});
```

#### Stateful with Zod

For stateful resources, provide both props and state schemas:

```ts
import { z } from "jsr:@zod/zod";
import { ZodResourceProvider } from "@brad-jones/terraform-provider-denobridge";

const Props = z.object({
  path: z.string(),
  content: z.string(),
  // Optional write-only properties (not stored in state)
  writeOnly: z.object({
    secretKey: z.string(),
  }).optional(),
});

const State = z.object({
  mtime: z.number(),
  sensitive: z.object({
    secret: z.string(),
  }),
});

new ZodResourceProvider(Props, State, {
  // as above but validated...
});
```
