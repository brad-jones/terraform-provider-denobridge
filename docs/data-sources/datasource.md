---
# generated by https://github.com/hashicorp/terraform-plugin-docs
page_title: "denobridge_datasource Data Source - terraform-provider-denobridge"
subcategory: ""
description: |-
  Bridges the terraform-plugin-framework Datasource to a Deno script.
---

# denobridge_datasource (Data Source)

Bridges the terraform-plugin-framework Datasource to a Deno script.

_Reference: <https://developer.hashicorp.com/terraform/plugin/framework/data-sources>_

## Example Usage

```terraform
data "denobridge_datasource" "deno_ip" {
  # The path to the underlying deno script.
  # Remote HTTP URLs also supported! Any valid value that `deno run` will accept.
  path = "${path.module}/data-source.ts"

  # The inputs required by the underlying deno script to read the data.
  props = {
    query = "deno.com."
    recordType = "A"
  }

  # Optionally provide a path to a deno config file.
  #
  # If none is given, the denobridge provider will attempt to locate the closest
  # config file relative to the script path. This is to ensure that things like
  # import maps work as expected.
  #
  # If you wish to opt out of this automatic config discovery, supply the path "/dev/null".
  config_file = "/path/to/deno.json"

  # Optionally set any runtime permissions that the deno script may require.
  permissions = {
    all = true # Maps to --allow-all (use with caution!)

    # Otherwise provide the exact permissions your script needs.
    # see: https://docs.deno.com/runtime/fundamentals/security/#permissions
    allow = ["read", "net=example.com:443"]
    deny = ["write"]
  }
}

resource "foo" "bar" {
  # The results are again untyped and dynamic based on the deno script returned
  # In this example we would receive the IP address from the A lookup against deno.com
  ip_address = data.denobridge_datasource.deno_ip.result[0]
}
```

<!-- schema generated by tfplugindocs -->

## Schema

### Required

- `path` (String) Path to the Deno script to execute.
- `props` (Dynamic) Input properties to pass to the Deno script.

### Optional

- `config_file` (String) File path to a deno config file to use with the deno script. Useful for import maps, etc...
- `permissions` (Attributes) Deno runtime permissions for the script. (see [below for nested schema](#nestedatt--permissions))

### Read-Only

- `result` (Dynamic) Output data returned from the Deno script.

<a id="nestedatt--permissions"></a>

### Nested Schema for `permissions`

Optional:

- `all` (Boolean) Grant all permissions.
- `allow` (List of String) List of permissions to allow (e.g., 'read', 'write', 'net').
- `deny` (List of String) List of permissions to deny.

## TypeScript Implementation

Simply create a new instance of the `DatasourceProvider`.

```ts
import { DatasourceProvider } from "@brad-jones/terraform-provider-denobridge";

interface Props {
  query: string;
  recordType: "A" | "AAAA" | "ANAME" | "CNAME" | "NS" | "PTR";
}

interface Result {
  ips: string[];
}

new DatasourceProvider<Props, Result>({
  async read({ query, recordType }) {
    return {
      ips: await Deno.resolveDns(query, recordType, {
        nameServer: { ipAddr: "1.1.1.1", port: 53 },
      }),
    };
  },
});
```

### Zod Validation

Alternatively you can use the `ZodDatasourceProvider`, this will ensure all
input & outputs to & from your TypeScript provider are validated at runtime.

```ts
import { z } from "jsr:@zod/zod";
import { ZodDatasourceProvider } from "@brad-jones/terraform-provider-denobridge";

const Props = z.object({
  query: z.string(),
  recordType: z.enum(["A", "AAAA", "ANAME", "CNAME", "NS", "PTR"]),
});

const Result = z.object({
  ips: z.array(z.string()),
});

new ZodDatasourceProvider(Props, Result, {
  // as above but validated...
});
```
