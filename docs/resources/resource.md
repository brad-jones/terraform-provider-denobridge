---
# generated by https://github.com/hashicorp/terraform-plugin-docs
page_title: "denobridge_resource Resource - terraform-provider-denobridge"
subcategory: ""
description: |-
  Bridges the terraform-plugin-framework Resource to a Deno script.
---

# denobridge_resource (Resource)

Bridges the terraform-plugin-framework Resource to a Deno script.

_Reference: <https://developer.hashicorp.com/terraform/plugin/framework/resources>_

## Example Usage

```terraform
resource "denobridge_resource" "quote_of_the_day" {
  # The path to the underlying deno script.
  # Remote HTTP URLs also supported! Any valid value that `deno run` will accept.
  path = "${path.module}/resource.ts"

  # The inputs required by the underlying deno script to read the data.
  props = {
    path = "quote.txt"
    content = "Minim cillum nisi reprehenderit enim mollit deserunt exercitation aliqua in mollit ex."
  }

  # Optionally provide a path to a deno config file.
  #
  # If none is given, the denobridge provider will attempt to locate the closest
  # config file relative to the script path. This is to ensure that things like
  # import maps work as expected.
  #
  # If you wish to opt out of this automatic config discovery, supply the path "/dev/null".
  config_file = "/path/to/deno.json"

  # Optionally set any runtime permissions that the deno script may require.
  permissions = {
    all = true # Maps to --allow-all (use with caution!)

    # Otherwise provide the exact permissions your script needs.
    # see: https://docs.deno.com/runtime/fundamentals/security/#permissions
    allow = ["read", "net=example.com:443"]
    deny = ["write"]
  }
}

resource "foo" "bar" {
  # Computed state (aka: outputs) available after the resource has been
  # created can be read from the dynamic & untyped state attribute.
  last_updated = resource.denobridge_resource.quote_of_the_day.state.mtime
}
```

<!-- schema generated by tfplugindocs -->

## Schema

### Required

- `path` (String) Path to the Deno script to execute.
- `props` (Dynamic) Input properties to pass to the Deno script.

### Optional

> **NOTE**: [Write-only arguments](https://developer.hashicorp.com/terraform/language/resources/ephemeral#write-only-arguments) are supported in Terraform 1.11 and later.

- `config_file` (String) File path to a deno config file to use with the deno script. Useful for import maps, etc...
- `permissions` (Attributes) Deno runtime permissions for the script. (see [below for nested schema](#nestedatt--permissions))
- `write_only_props` (Dynamic, [Write-only](https://developer.hashicorp.com/terraform/language/resources/ephemeral#write-only-arguments)) Input properties to pass to the Deno script that are write-only.

### Read-Only

- `id` (String) Unique identifier for the resource.
- `sensitive_state` (Dynamic, Sensitive) Sensitive computed state of the resource as returned by the Deno script. This value is marked as sensitive and will not be displayed in logs or plan output.
- `state` (Dynamic) Additional computed state of the resource as returned by the Deno script.
- `write_only_props_version` (Number) Version of the write-only properties.

<a id="nestedatt--permissions"></a>

### Nested Schema for `permissions`

Optional:

- `all` (Boolean) Grant all permissions.
- `allow` (List of String) List of permissions to allow (e.g., 'read', 'write', 'net').
- `deny` (List of String) List of permissions to deny.

## Write-Only Properties

Write-only properties (available in Terraform 1.11+) allow you to pass sensitive or ephemeral data to your resource without storing it in Terraform state. This is particularly useful when working with ephemeral resources like temporary credentials or tokens.

### Usage Example

```terraform
ephemeral "denobridge_ephemeral_resource" "api_token" {
  path = "./get_token.ts"
  props = {
    service = "example-api"
  }
}

resource "denobridge_resource" "api_call" {
  path  = "./resource.ts"
  props = {
    endpoint = "https://api.example.com"
    action = "create"
  }

  # Write-only props are not stored in state
  write_only_props = {
    apiToken = ephemeral.denobridge_ephemeral_resource.api_token.result.token
  }
}
```

### How It Works

1. **No State Storage**: Write-only properties are never stored in Terraform state
2. **Change Detection**: Changes to write-only properties trigger resource updates via the `write_only_props_version` field
3. **Passed to Script**: Write-only properties are available to your Deno script under `props.writeOnly`

### In Your TypeScript Implementation

Access write-only properties through the `writeOnly` nested field in your props interface:

```ts
interface Props {
  endpoint: string;
  action: string;

  // Write-only properties nested under "writeOnly" key
  writeOnly?: {
    apiToken: string;
  };
}

new ResourceProvider<Props>({
  async create(props) {
    // Access write-only data
    const token = props.writeOnly?.apiToken;

    // Use it to create the resource
    await makeApiCall(props.endpoint, token);

    return { id: "resource-id" };
  },
  // ... other methods can also access props.writeOnly
});
```

**Important Notes:**

- Write-only properties are separate from sensitive state values
- Sensitive state values are stored (but marked as sensitive), while write-only properties are never stored
- Changes to write-only properties will cause an update operation, not just a plan refresh

## Import

Import is supported using the following syntax:

In Terraform v1.5.0 and later, the [`import` block](https://developer.hashicorp.com/terraform/language/import) can be used with the `id` attribute, for example:

```terraform
import {
  to = denobridge_resource.quote_of_the_day

  # The Import ID is a JSON encoded string
  id = jsonencode({
    # At a minimum you need to provide the path to the deno script
    path = "${path.module}/resource.ts"

    # Optionally you may need to set deno permissions
    permissions = {
      all = true
    }

    # Of course the id of the actual resource must be given too.
    id = "quote.txt"

    # And depending on the implementation of the resource script you may also
    # need to supply some of the props so that the resource can be uniquely identified.
    props = {
      foo = "bar"
    }
  })
}
```

The [`terraform import` command](https://developer.hashicorp.com/terraform/cli/commands/import) can be used, for example:

```shell
terraform import denobridge_resource.quote_of_the_day '{"id":"quote.txt","path":"./resource.ts","permissions":{"all":true}}'
```

## TypeScript Implementation

Resources can be either **stateful** or **stateless**:

- **Stateful Resources**: Maintain additional computed state beyond the ID and props (e.g., timestamps, checksums, server-generated values)
- **Stateless Resources**: Only need an ID and props, without additional state tracking

### Stateless Resource Example

When you don't need to track additional state, omit the state type parameter:

```ts
import { ResourceProvider } from "@brad-jones/terraform-provider-denobridge";

interface Props {
  path: string;
  content: string;

  // Optional write-only properties (not stored in state)
  writeOnly?: {
    secretKey: string;
  };
}

new ResourceProvider<Props>({
  async create({ path, content }) {
    await Deno.writeTextFile(path, content);

    // For stateless resources, only return the ID
    return { id: path };
  },
  async read(id, props) {
    try {
      const content = await Deno.readTextFile(id);
      // Return only props, no state
      return { props: { path: id, content } };
    } catch (e) {
      if (e instanceof Deno.errors.NotFound) {
        return { exists: false };
      }
      throw e;
    }
  },
  async update(id, nextProps, currentProps) {
    if (nextProps.path !== currentProps.path) {
      throw new Error("Cannot change file path - requires resource replacement");
    }
    await Deno.writeTextFile(id, nextProps.content);
    // No state to return
  },
  async delete(id, props) {
    await Deno.remove(id);
  },
  async modifyPlan(_id, planType, nextProps, currentProps) {
    if (planType !== "update") return;
    return { requiresReplacement: currentProps?.path !== nextProps.path };
  },
});
```

### Stateful Resource Example

When you need to track additional computed state, provide both props and state types:

```ts
import { ResourceProvider } from "@brad-jones/terraform-provider-denobridge";

interface Props {
  path: string;
  content: string;

  // Optional write-only properties (not stored in state)
  writeOnly?: {
    secretKey: string;
  };
}

interface State {
  mtime: number;
  sensitive: {
    secret: string;
  };
}

new ResourceProvider<Props, State>({
  async create({ path, content }) {
    await Deno.writeTextFile(path, content);

    return {
      // At minimum, the create endpoint must return an id that uniquely identifies this resource.
      id: path,

      // Optional additional state that is only known after the resource is created can be returned in the state object.
      state: {
        mtime: (await Deno.stat(path)).mtime!.getTime(),
        // Sensitive values can be nested under a "sensitive" key to mark them as sensitive in Terraform
        sensitive: {
          secret: "api-key-or-password",
        },
      },
    };
  },
  async read(id, props) {
    // The read methods job is to get the current state of an existing resource.
    // And return an updated set of props & optional additional state that may
    // have changed (by outside actors), since the resource was initially created
    // (or last updated).
    try {
      const content = await Deno.readTextFile(id);
      return {
        props: { path: id, content },
        state: {
          mtime: (await Deno.stat(id)).mtime!.getTime(),
          sensitive: {
            secret: "api-key-or-password",
          },
        },
      };
    } catch (e) {
      if (e instanceof Deno.errors.NotFound) {
        // In the event we can no longer locate the resource we should signal
        // to tf to remove the resource from state. This will cause tf to re-create
        // the resource on the next plan.
        return { exists: false };
      }
      throw e;
    }
  },
  async update(id, nextProps, currentProps, currentState) {
    // In this case an in place update is not supported for a file when the path
    // changes because that would mean the ID would change too & tf can't deal with that easily.
    // So we return an error here but if an update wouldn't result in a new ID, there is no need to return such an error.
    // Or implement the /modify-plan endpoint, which should have caught this & told tf to do a replacement instead (ie: create then delete).
    if (nextProps.path !== currentProps.path) {
      throw new Error("Cannot change file path - requires resource replacement");
    }

    // Perform the update
    await Deno.writeTextFile(id, nextProps.content);

    // Return the updated state
    return {
      mtime: (await Deno.stat(id)).mtime!.getTime(),
      sensitive: {
        secret: "api-key-or-password",
      },
    };
  },
  async delete(id, _props, _state) {
    await Deno.remove(id);
  },
  async modifyPlan(_id, planType, nextProps, currentProps, currentState) {
    // If you decide you don't want to make any changes to the plan, just return a 204 No Content response.
    if (planType !== "update") {
      return;
    }

    // The most common use case for this endpoint is to tell tf if the resource
    // requires replacement (ie: create then delete) instead of an inline update.
    return { requiresReplacement: currentProps?.path !== nextProps.path };

    // Other use cases include returning a set of modifiedProps.
    // For example to provide default values for any unset props.
    // eg: return { modifiedProps: { content: nextProps?.content ?? "Hello World" } }

    // Or returning diagnostics, eg: for Destroy plans. As well as any other validation.
    // see: https://developer.hashicorp.com/terraform/plugin/framework/resources/plan-modification#resource-destroy-plan-diagnostics
    // eg: return {
    //   diagnostics: [{
    //     severity: "warning",
    //     summary: "Resource Destruction Considerations",
    //     detail: `Applying this resource destruction will only remove the resource
    //             from the Terraform state and will not call the deletion API due to API limitations.
    //             Manually use the web interface to fully destroy this resource.`
    //   }]
    // }
  },
});
```

### Sensitive State

Resources can return sensitive values (like API keys, passwords, or tokens) that should be marked as sensitive in Terraform. Sensitive values will not be displayed in logs or plan output.

To mark state as sensitive, nest it under a `sensitive` key within your state object:

```ts
interface State {
  mtime: number;
  sensitive: {
    apiKey: string;
    password: string;
  };
}

new ResourceProvider<Props, State>({
  async create(props) {
    // ... create resource
    return {
      id: "resource-id",
      state: {
        mtime: Date.now(),
        sensitive: {
          apiKey: "secret-api-key",
          password: "secret-password",
        },
      },
    };
  },
  // ... other methods also return sensitive state
});
```

The `sensitive` field is automatically separated from the rest of the state and stored in the `sensitive_state` attribute of the resource, which is marked as sensitive in the Terraform schema.

**Important**: When accessing `currentState` in the `update`, `delete`, or `modifyPlan` methods, the sensitive values will be available under `currentState.sensitive`.

### Zod Validation

The `ZodResourceProvider` ensures all input & outputs to & from your TypeScript provider are validated at runtime.

#### Stateless with Zod

For stateless resources, provide only the props schema:

```ts
import { z } from "jsr:@zod/zod";
import { ZodResourceProvider } from "@brad-jones/terraform-provider-denobridge";

const Props = z.object({
  path: z.string(),
  content: z.string(),
  // Optional write-only properties (not stored in state)
  writeOnly: z.object({
    secretKey: z.string(),
  }).optional(),
});

new ZodResourceProvider(Props, {
  async create({ path, content }) {
    await Deno.writeTextFile(path, content);
    return { id: path };
  },
  async read(id, props) {
    const content = await Deno.readTextFile(id);
    return { props: { path: id, content } };
  },
  async update(id, nextProps, currentProps) {
    await Deno.writeTextFile(id, nextProps.content);
  },
  async delete(id, props) {
    await Deno.remove(id);
  },
  // ... other methods
});
```

#### Stateful with Zod

For stateful resources, provide both props and state schemas:

```ts
import { z } from "jsr:@zod/zod";
import { ZodResourceProvider } from "@brad-jones/terraform-provider-denobridge";

const Props = z.object({
  path: z.string(),
  content: z.string(),
  // Optional write-only properties (not stored in state)
  writeOnly: z.object({
    secretKey: z.string(),
  }).optional(),
});

const State = z.object({
  mtime: z.number(),
  sensitive: z.object({
    secret: z.string(),
  }),
});

new ZodResourceProvider(Props, State, {
  // as above but validated...
});
```
