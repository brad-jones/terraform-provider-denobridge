---
# generated by https://github.com/hashicorp/terraform-plugin-docs
page_title: "denobridge_resource Resource - terraform-provider-denobridge"
subcategory: ""
description: |-
  Bridges the terraform-plugin-framework Resource to a Deno script.
---

# denobridge_resource (Resource)

Bridges the terraform-plugin-framework Resource to a Deno script.

_Reference: <https://developer.hashicorp.com/terraform/plugin/framework/resources>_

## Example Usage

```terraform
resource "denobridge_resource" "quote_of_the_day" {
  # The path to the underlying deno script.
  # Remote HTTP URLs also supported! Any valid value that `deno run` will accept.
  path = "${path.module}/resource.ts"

  # The inputs required by the underlying deno script to read the data.
  props = {
    path = "quote.txt"
    content = "Minim cillum nisi reprehenderit enim mollit deserunt exercitation aliqua in mollit ex."
  }

  # Optionally provide a path to a deno config file.
  #
  # If none is given, the denobridge provider will attempt to locate the closest
  # config file relative to the script path. This is to ensure that things like
  # import maps work as expected.
  #
  # If you wish to opt out of this automatic config discovery, supply the path "/dev/null".
  config_file = "/path/to/deno.json"

  # Optionally set any runtime permissions that the deno script may require.
  permissions = {
    all = true # Maps to --allow-all (use with caution!)

    # Otherwise provide the exact permissions your script needs.
    # see: https://docs.deno.com/runtime/fundamentals/security/#permissions
    allow = ["read", "net=example.com:443"]
    deny = ["write"]
  }
}

resource "foo" "bar" {
  # Computed state (aka: outputs) available after the resource has been
  # created can be read from the dynamic & untyped state attribute.
  last_updated = resource.denobridge_resource.quote_of_the_day.state.mtime
}
```

<!-- schema generated by tfplugindocs -->

## Schema

### Required

- `path` (String) Path to the Deno script to execute.

### Optional

- `config_file` (String) File path to a deno config file to use with the deno script. Useful for import maps, etc...
- `permissions` (Attributes) Deno runtime permissions for the script. (see [below for nested schema](#nestedatt--permissions))
- `props` (Dynamic) Input properties to pass to the Deno script.

### Read-Only

- `id` (String) Unique identifier for the resource.
- `state` (Dynamic) Additional computed state of the resource as returned by the Deno script.

<a id="nestedatt--permissions"></a>

### Nested Schema for `permissions`

Optional:

- `all` (Boolean) Grant all permissions.
- `allow` (List of String) List of permissions to allow (e.g., 'read', 'write', 'net').
- `deny` (List of String) List of permissions to deny.

## Import

Import is supported using the following syntax:

In Terraform v1.5.0 and later, the [`import` block](https://developer.hashicorp.com/terraform/language/import) can be used with the `id` attribute, for example:

```terraform
import {
  to = denobridge_resource.quote_of_the_day

  # The Import ID is a JSON encoded string
  id = jsonencode({
    # At a minimum you need to provide the path to the deno script
    path = "${path.module}/resource.ts"

    # Optionally you may need to set deno permissions
    permissions = {
      all = true
    }

    # Of course the id of the actual resource must be given too.
    id = "quote.txt"

    # And depending on the implementation of the resource script you may also
    # need to supply some of the props so that the resource can be uniquely identified.
    props = {
      foo = "bar"
    }
  })
}
```

The [`terraform import` command](https://developer.hashicorp.com/terraform/cli/commands/import) can be used, for example:

```shell
terraform import denobridge_resource.quote_of_the_day '{"id":"quote.txt","path":"./resource.ts","permissions":{"all":true}}'
```

## TypeScript Implementation

Simply create a new instance of the `ResourceProvider`.

```ts
import { ResourceProvider } from "@brad-jones/terraform-provider-denobridge";

interface Props {
  path: string;
  content: string;
}

interface State {
  mtime: number;
}

new ResourceProvider<Props, State>({
  async create({ path, content }) {
    await Deno.writeTextFile(path, content);

    return {
      // At minimum, the create endpoint must return an id that uniquely identifies this resource.
      id: path,

      // Optional additional state that is only known after the resource is created can be returned in the state object.
      state: {
        mtime: (await Deno.stat(path)).mtime!.getTime(),
      },
    };
  },
  async read(id, props) {
    // The read methods job is to get the current state of an existing resource.
    // And return an updated set of props & optional additional state that may
    // have changed (by outside actors), since the resource was initially created
    // (or last updated).
    try {
      const content = await Deno.readTextFile(id);
      return {
        props: { path: id, content },
        state: {
          mtime: (await Deno.stat(id)).mtime!.getTime(),
        },
      };
    } catch (e) {
      if (e instanceof Deno.errors.NotFound) {
        // In the event we can no longer locate the resource we should signal
        // to tf to remove the resource from state. This will cause tf to re-create
        // the resource on the next plan.
        return { exists: false };
      }
      throw e;
    }
  },
  async update(id, nextProps, currentProps, currentState) {
    // In this case an in place update is not supported for a file when the path
    // changes because that would mean the ID would change too & tf can't deal with that easily.
    // So we return an error here but if an update wouldn't result in a new ID, there is no need to return such an error.
    // Or implement the /modify-plan endpoint, which should have caught this & told tf to do a replacement instead (ie: create then delete).
    if (nextProps.path !== currentProps.path) {
      throw new Error("Cannot change file path - requires resource replacement");
    }

    // Perform the update
    await Deno.writeTextFile(id, nextProps.content);

    // Return the updated state
    return { mtime: (await Deno.stat(id)).mtime!.getTime() };
  },
  async delete(id, _props, _state) {
    await Deno.remove(id);
  },
  async modifyPlan(_id, planType, nextProps, currentProps, currentState) {
    // If you decide you don't want to make any changes to the plan, just return a 204 No Content response.
    if (planType !== "update") {
      return;
    }

    // The most common use case for this endpoint is to tell tf if the resource
    // requires replacement (ie: create then delete) instead of an inline update.
    return { requiresReplacement: currentProps?.path !== nextProps.path };

    // Other use cases include returning a set of modifiedProps.
    // For example to provide default values for any unset props.
    // eg: return { modifiedProps: { content: nextProps?.content ?? "Hello World" } }

    // Or returning diagnostics, eg: for Destroy plans. As well as any other validation.
    // see: https://developer.hashicorp.com/terraform/plugin/framework/resources/plan-modification#resource-destroy-plan-diagnostics
    // eg: return {
    //   diagnostics: [{
    //     severity: "warning",
    //     summary: "Resource Destruction Considerations",
    //     detail: `Applying this resource destruction will only remove the resource
    //             from the Terraform state and will not call the deletion API due to API limitations.
    //             Manually use the web interface to fully destroy this resource.`
    //   }]
    // }
  },
});
```

### Zod Validation

Alternatively you can use the `ZodResourceProvider`, this will ensure all
input & outputs to & from your TypeScript provider are validated at runtime.

```ts
import { z } from "jsr:@zod/zod";
import { ZodResourceProvider } from "@brad-jones/terraform-provider-denobridge";

const Props = z.object({
  path: z.string(),
  content: z.string(),
});

const State = z.object({
  mtime: z.number(),
});

new ZodResourceProvider(Props, State, {
  // as above but validated...
});
```
